// <auto-generated/>
using System;
using System.Buffers.Binary;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using FourSer.Contracts;
using System.IO;
using FourSer.Gen.Helpers;
using SpanReader = FourSer.Gen.Helpers.RoSpanReaderHelpers;
using StreamReader = FourSer.Gen.Helpers.StreamReaderHelpers;
using SpanWriter = FourSer.Gen.Helpers.SpanWriterHelpers;
using StreamWriter = FourSer.Gen.Helpers.StreamWriterHelpers;

namespace FourSer.Tests.GeneratorTestCases.EnumerationTypes;

public partial class EnumerationTypesPacket : ISerializable<EnumerationTypesPacket>
{
    public static int GetPacketSize(EnumerationTypesPacket obj)
    {
        var size = 0;
        size += sizeof(int); // Count size for Numbers
        size += (obj.Numbers?.Count ?? 0) * sizeof(int);
        size += sizeof(int); // Count size for Names
        if (obj.Names is not null)
        {
            foreach(var item in obj.Names) { size += StringEx.MeasureSize(item); }
        }
        size += sizeof(int); // Count size for Data
        size += (obj.Data?.Count() ?? 0) * sizeof(byte);
        size += sizeof(int); // Count size for Data1
        size += (obj.Data1?.Count ?? 0) * sizeof(byte);
        size += sizeof(int); // Count size for Values
        size += (obj.Values?.Count ?? 0) * sizeof(float);
        size += sizeof(int); // Count size for UniqueIds
        size += (obj.UniqueIds?.Count ?? 0) * sizeof(long);
        size += sizeof(int); // Count size for ProcessingQueue
        size += (obj.ProcessingQueue?.Count ?? 0) * sizeof(ushort);
        size += sizeof(int); // Count size for ProcessingStack
        size += (obj.ProcessingStack?.Count ?? 0) * sizeof(uint);
        size += sizeof(int); // Count size for ArrayData
        size += (obj.ArrayData?.Length ?? 0) * sizeof(int);
        size += sizeof(int); // Count size for Measurements
        size += (obj.Measurements?.Count() ?? 0) * sizeof(double);
        size += sizeof(int); // Count size for Flags
        size += (obj.Flags?.Count ?? 0) * sizeof(bool);
        size += sizeof(int); // Count size for ObservableData
        size += (obj.ObservableData?.Count ?? 0) * sizeof(short);
        size += sizeof(int); // Count size for Characters
        size += (obj.Characters?.Count ?? 0) * sizeof(ushort);
        size += sizeof(int); // Count size for SortedValues
        size += (obj.SortedValues?.Count ?? 0) * sizeof(long);
        size += sizeof(byte); // Count size for SmallSet
        if (obj.SmallSet is not null)
        {
            foreach(var item in obj.SmallSet) { size += StringEx.MeasureSize(item); }
        }
        size += sizeof(ushort); // Count size for MediumQueue
        size += (obj.MediumQueue?.Count ?? 0) * sizeof(int);
        size += (obj.LargeBag?.Count ?? 0) * sizeof(long);
        return size;
    }

    private EnumerationTypesPacket(System.Collections.Generic.List<int> numbers, System.Collections.Generic.ICollection<string> names, System.Collections.Generic.IEnumerable<byte> data, System.Collections.Generic.List<byte> data1, System.Collections.Concurrent.ConcurrentBag<float> values, System.Collections.Generic.HashSet<long> uniqueIds, System.Collections.Generic.Queue<ushort> processingQueue, System.Collections.Generic.Stack<uint> processingStack, int[] arrayData, System.Collections.Generic.IList<double> measurements, System.Collections.ObjectModel.Collection<bool> flags, System.Collections.ObjectModel.ObservableCollection<short> observableData, System.Collections.Generic.LinkedList<ushort> characters, System.Collections.Generic.SortedSet<long> sortedValues, System.Collections.Generic.HashSet<string> smallSet, System.Collections.Generic.Queue<int> mediumQueue, System.Collections.Concurrent.ConcurrentBag<long> largeBag)
    {
        this.Numbers = numbers;
        this.Names = names;
        this.Data = data;
        this.Data1 = data1;
        this.Values = values;
        this.UniqueIds = uniqueIds;
        this.ProcessingQueue = processingQueue;
        this.ProcessingStack = processingStack;
        this.ArrayData = arrayData;
        this.Measurements = measurements;
        this.Flags = flags;
        this.ObservableData = observableData;
        this.Characters = characters;
        this.SortedValues = sortedValues;
        this.SmallSet = smallSet;
        this.MediumQueue = mediumQueue;
        this.LargeBag = largeBag;
    }

    public EnumerationTypesPacket()
    {
        this.Numbers = default;
        this.Names = default;
        this.Data = default;
        this.Data1 = default;
        this.Values = default;
        this.UniqueIds = default;
        this.ProcessingQueue = default;
        this.ProcessingStack = default;
        this.ArrayData = default;
        this.Measurements = default;
        this.Flags = default;
        this.ObservableData = default;
        this.Characters = default;
        this.SortedValues = default;
        this.SmallSet = default;
        this.MediumQueue = default;
        this.LargeBag = default;
    }

    public static EnumerationTypesPacket Deserialize(ref System.ReadOnlySpan<byte> buffer)
    {
        var numbersCount = SpanReader.ReadInt32(ref buffer);
        var numbers = new System.Collections.Generic.List<int>(numbersCount);
        for (int i = 0; i < numbersCount; i++)
        {
            numbers.Add(SpanReader.ReadInt32(ref buffer));
        }
        var namesCount = SpanReader.ReadInt32(ref buffer);
        var names = new System.Collections.Generic.List<string>(namesCount);
        for (int i = 0; i < namesCount; i++)
        {
            names.Add(SpanReader.ReadString(ref buffer));
        }
        var dataCount = SpanReader.ReadInt32(ref buffer);
        var data = SpanReader.ReadBytes(ref buffer, (int)dataCount);
        var data1Count = SpanReader.ReadInt32(ref buffer);
        var data1 = SpanReader.ReadBytes(ref buffer, (int)data1Count).ToList();
        var valuesCount = SpanReader.ReadInt32(ref buffer);
        var values = new System.Collections.Concurrent.ConcurrentBag<float>();
        for (int i = 0; i < valuesCount; i++)
        {
            values.Add(SpanReader.ReadSingle(ref buffer));
        }
        var uniqueIdsCount = SpanReader.ReadInt32(ref buffer);
        var uniqueIds = new System.Collections.Generic.HashSet<long>(uniqueIdsCount);
        for (int i = 0; i < uniqueIdsCount; i++)
        {
            uniqueIds.Add(SpanReader.ReadInt64(ref buffer));
        }
        var processingQueueCount = SpanReader.ReadInt32(ref buffer);
        var processingQueue = new System.Collections.Generic.Queue<ushort>(processingQueueCount);
        for (int i = 0; i < processingQueueCount; i++)
        {
            processingQueue.Enqueue(SpanReader.ReadUInt16(ref buffer));
        }
        var processingStackCount = SpanReader.ReadInt32(ref buffer);
        var processingStack = new System.Collections.Generic.Stack<uint>(processingStackCount);
        for (int i = 0; i < processingStackCount; i++)
        {
            processingStack.Push(SpanReader.ReadUInt32(ref buffer));
        }
        var arrayDataCount = SpanReader.ReadInt32(ref buffer);
        var arrayData = new int[arrayDataCount];
        for (int i = 0; i < arrayDataCount; i++)
        {
            arrayData[i] = SpanReader.ReadInt32(ref buffer);
        }
        var measurementsCount = SpanReader.ReadInt32(ref buffer);
        var measurements = new System.Collections.Generic.List<double>(measurementsCount);
        for (int i = 0; i < measurementsCount; i++)
        {
            measurements.Add(SpanReader.ReadDouble(ref buffer));
        }
        var flagsCount = SpanReader.ReadInt32(ref buffer);
        var flags = new System.Collections.ObjectModel.Collection<bool>();
        for (int i = 0; i < flagsCount; i++)
        {
            flags.Add(SpanReader.ReadBoolean(ref buffer));
        }
        var observableDataCount = SpanReader.ReadInt32(ref buffer);
        var observableData = new System.Collections.ObjectModel.ObservableCollection<short>();
        for (int i = 0; i < observableDataCount; i++)
        {
            observableData.Add(SpanReader.ReadInt16(ref buffer));
        }
        var charactersCount = SpanReader.ReadInt32(ref buffer);
        var characters = new System.Collections.Generic.LinkedList<ushort>();
        for (int i = 0; i < charactersCount; i++)
        {
            characters.AddLast(SpanReader.ReadUInt16(ref buffer));
        }
        var sortedValuesCount = SpanReader.ReadInt32(ref buffer);
        var sortedValues = new System.Collections.Generic.SortedSet<long>();
        for (int i = 0; i < sortedValuesCount; i++)
        {
            sortedValues.Add(SpanReader.ReadInt64(ref buffer));
        }
        var smallSetCount = SpanReader.ReadByte(ref buffer);
        var smallSet = new System.Collections.Generic.HashSet<string>(smallSetCount);
        for (int i = 0; i < smallSetCount; i++)
        {
            smallSet.Add(SpanReader.ReadString(ref buffer));
        }
        var mediumQueueCount = SpanReader.ReadUInt16(ref buffer);
        var mediumQueue = new System.Collections.Generic.Queue<int>(mediumQueueCount);
        for (int i = 0; i < mediumQueueCount; i++)
        {
            mediumQueue.Enqueue(SpanReader.ReadInt32(ref buffer));
        }
        var largeBag = new System.Collections.Concurrent.ConcurrentBag<long>();
        for (int i = 0; i < 8; i++)
        {
            largeBag.Add(SpanReader.ReadInt64(ref buffer));
        }
        var obj = new EnumerationTypesPacket(numbers, names, data, data1, values, uniqueIds, processingQueue, processingStack, arrayData, measurements, flags, observableData, characters, sortedValues, smallSet, mediumQueue, largeBag);
        return obj;
    }

    public static EnumerationTypesPacket Deserialize(System.ReadOnlySpan<byte> buffer)
    {
        return Deserialize(ref buffer);
    }

    public static EnumerationTypesPacket Deserialize(System.IO.Stream stream)
    {
        var numbersCount = StreamReader.ReadInt32(stream);
        var numbers = new System.Collections.Generic.List<int>(numbersCount);
        for (int i = 0; i < numbersCount; i++)
        {
            numbers.Add(StreamReader.ReadInt32(stream));
        }
        var namesCount = StreamReader.ReadInt32(stream);
        var names = new System.Collections.Generic.List<string>(namesCount);
        for (int i = 0; i < namesCount; i++)
        {
            names.Add(StreamReader.ReadString(stream));
        }
        var dataCount = StreamReader.ReadInt32(stream);
        var data = StreamReader.ReadBytes(stream, (int)dataCount);
        var data1Count = StreamReader.ReadInt32(stream);
        var data1 = StreamReader.ReadBytes(stream, (int)data1Count).ToList();
        var valuesCount = StreamReader.ReadInt32(stream);
        var values = new System.Collections.Concurrent.ConcurrentBag<float>();
        for (int i = 0; i < valuesCount; i++)
        {
            values.Add(StreamReader.ReadSingle(stream));
        }
        var uniqueIdsCount = StreamReader.ReadInt32(stream);
        var uniqueIds = new System.Collections.Generic.HashSet<long>(uniqueIdsCount);
        for (int i = 0; i < uniqueIdsCount; i++)
        {
            uniqueIds.Add(StreamReader.ReadInt64(stream));
        }
        var processingQueueCount = StreamReader.ReadInt32(stream);
        var processingQueue = new System.Collections.Generic.Queue<ushort>(processingQueueCount);
        for (int i = 0; i < processingQueueCount; i++)
        {
            processingQueue.Enqueue(StreamReader.ReadUInt16(stream));
        }
        var processingStackCount = StreamReader.ReadInt32(stream);
        var processingStack = new System.Collections.Generic.Stack<uint>(processingStackCount);
        for (int i = 0; i < processingStackCount; i++)
        {
            processingStack.Push(StreamReader.ReadUInt32(stream));
        }
        var arrayDataCount = StreamReader.ReadInt32(stream);
        var arrayData = new int[arrayDataCount];
        for (int i = 0; i < arrayDataCount; i++)
        {
            arrayData[i] = StreamReader.ReadInt32(stream);
        }
        var measurementsCount = StreamReader.ReadInt32(stream);
        var measurements = new System.Collections.Generic.List<double>(measurementsCount);
        for (int i = 0; i < measurementsCount; i++)
        {
            measurements.Add(StreamReader.ReadDouble(stream));
        }
        var flagsCount = StreamReader.ReadInt32(stream);
        var flags = new System.Collections.ObjectModel.Collection<bool>();
        for (int i = 0; i < flagsCount; i++)
        {
            flags.Add(StreamReader.ReadBoolean(stream));
        }
        var observableDataCount = StreamReader.ReadInt32(stream);
        var observableData = new System.Collections.ObjectModel.ObservableCollection<short>();
        for (int i = 0; i < observableDataCount; i++)
        {
            observableData.Add(StreamReader.ReadInt16(stream));
        }
        var charactersCount = StreamReader.ReadInt32(stream);
        var characters = new System.Collections.Generic.LinkedList<ushort>();
        for (int i = 0; i < charactersCount; i++)
        {
            characters.AddLast(StreamReader.ReadUInt16(stream));
        }
        var sortedValuesCount = StreamReader.ReadInt32(stream);
        var sortedValues = new System.Collections.Generic.SortedSet<long>();
        for (int i = 0; i < sortedValuesCount; i++)
        {
            sortedValues.Add(StreamReader.ReadInt64(stream));
        }
        var smallSetCount = StreamReader.ReadByte(stream);
        var smallSet = new System.Collections.Generic.HashSet<string>(smallSetCount);
        for (int i = 0; i < smallSetCount; i++)
        {
            smallSet.Add(StreamReader.ReadString(stream));
        }
        var mediumQueueCount = StreamReader.ReadUInt16(stream);
        var mediumQueue = new System.Collections.Generic.Queue<int>(mediumQueueCount);
        for (int i = 0; i < mediumQueueCount; i++)
        {
            mediumQueue.Enqueue(StreamReader.ReadInt32(stream));
        }
        var largeBag = new System.Collections.Concurrent.ConcurrentBag<long>();
        for (int i = 0; i < 8; i++)
        {
            largeBag.Add(StreamReader.ReadInt64(stream));
        }
        var obj = new EnumerationTypesPacket(numbers, names, data, data1, values, uniqueIds, processingQueue, processingStack, arrayData, measurements, flags, observableData, characters, sortedValues, smallSet, mediumQueue, largeBag);
        return obj;
    }

    public static int Serialize(EnumerationTypesPacket obj, System.Span<byte> data)
    {
        var originalData = data;
        if (obj.Numbers is null)
        {
            SpanWriter.WriteInt32(ref data, (int)(0));
        }
        else
        {
            SpanWriter.WriteInt32(ref data, (int)(obj.Numbers.Count));
            for (int i = 0; i < obj.Numbers.Count; i++)
            {
                SpanWriter.WriteInt32(ref data, (int)(obj.Numbers[i]));
            }
        }
        if (obj.Names is null)
        {
            SpanWriter.WriteInt32(ref data, (int)(0));
        }
        else
        {
            SpanWriter.WriteInt32(ref data, (int)(obj.Names.Count()));
            foreach (var item in obj.Names)
            {
                SpanWriter.WriteString(ref data, item);
            }
        }
        if (obj.Data is null)
        {
            SpanWriter.WriteInt32(ref data, (int)(0));
        }
        else
        {
            SpanWriter.WriteInt32(ref data, (int)(obj.Data.Count()));
            SpanWriter.WriteBytes(ref data, obj.Data);
        }
        if (obj.Data1 is null)
        {
            SpanWriter.WriteInt32(ref data, (int)(0));
        }
        else
        {
            SpanWriter.WriteInt32(ref data, (int)(obj.Data1.Count));
            SpanWriter.WriteBytes(ref data, obj.Data1);
        }
        if (obj.Values is null)
        {
            SpanWriter.WriteInt32(ref data, (int)(0));
        }
        else
        {
            SpanWriter.WriteInt32(ref data, (int)(obj.Values.Count));
            foreach (var item in obj.Values)
            {
                SpanWriter.WriteSingle(ref data, (float)(item));
            }
        }
        if (obj.UniqueIds is null)
        {
            SpanWriter.WriteInt32(ref data, (int)(0));
        }
        else
        {
            SpanWriter.WriteInt32(ref data, (int)(obj.UniqueIds.Count));
            foreach (var item in obj.UniqueIds)
            {
                SpanWriter.WriteInt64(ref data, (long)(item));
            }
        }
        if (obj.ProcessingQueue is null)
        {
            SpanWriter.WriteInt32(ref data, (int)(0));
        }
        else
        {
            SpanWriter.WriteInt32(ref data, (int)(obj.ProcessingQueue.Count));
            foreach (var item in obj.ProcessingQueue)
            {
                SpanWriter.WriteUInt16(ref data, (ushort)(item));
            }
        }
        if (obj.ProcessingStack is null)
        {
            SpanWriter.WriteInt32(ref data, (int)(0));
        }
        else
        {
            SpanWriter.WriteInt32(ref data, (int)(obj.ProcessingStack.Count));
            foreach (var item in obj.ProcessingStack)
            {
                SpanWriter.WriteUInt32(ref data, (uint)(item));
            }
        }
        if (obj.ArrayData is null)
        {
            SpanWriter.WriteInt32(ref data, (int)(0));
        }
        else
        {
            SpanWriter.WriteInt32(ref data, (int)(obj.ArrayData.Length));
            for (int i = 0; i < obj.ArrayData.Length; i++)
            {
                SpanWriter.WriteInt32(ref data, (int)(obj.ArrayData[i]));
            }
        }
        if (obj.Measurements is null)
        {
            SpanWriter.WriteInt32(ref data, (int)(0));
        }
        else
        {
            SpanWriter.WriteInt32(ref data, (int)(obj.Measurements.Count()));
            foreach (var item in obj.Measurements)
            {
                SpanWriter.WriteDouble(ref data, (double)(item));
            }
        }
        if (obj.Flags is null)
        {
            SpanWriter.WriteInt32(ref data, (int)(0));
        }
        else
        {
            SpanWriter.WriteInt32(ref data, (int)(obj.Flags.Count));
            foreach (var item in obj.Flags)
            {
                SpanWriter.WriteBoolean(ref data, (bool)(item));
            }
        }
        if (obj.ObservableData is null)
        {
            SpanWriter.WriteInt32(ref data, (int)(0));
        }
        else
        {
            SpanWriter.WriteInt32(ref data, (int)(obj.ObservableData.Count));
            foreach (var item in obj.ObservableData)
            {
                SpanWriter.WriteInt16(ref data, (short)(item));
            }
        }
        if (obj.Characters is null)
        {
            SpanWriter.WriteInt32(ref data, (int)(0));
        }
        else
        {
            SpanWriter.WriteInt32(ref data, (int)(obj.Characters.Count));
            foreach (var item in obj.Characters)
            {
                SpanWriter.WriteUInt16(ref data, (ushort)(item));
            }
        }
        if (obj.SortedValues is null)
        {
            SpanWriter.WriteInt32(ref data, (int)(0));
        }
        else
        {
            SpanWriter.WriteInt32(ref data, (int)(obj.SortedValues.Count));
            foreach (var item in obj.SortedValues)
            {
                SpanWriter.WriteInt64(ref data, (long)(item));
            }
        }
        if (obj.SmallSet is null)
        {
            SpanWriter.WriteByte(ref data, (byte)(0));
        }
        else
        {
            SpanWriter.WriteByte(ref data, (byte)(obj.SmallSet.Count));
            foreach (var item in obj.SmallSet)
            {
                SpanWriter.WriteString(ref data, item);
            }
        }
        if (obj.MediumQueue is null)
        {
            SpanWriter.WriteUInt16(ref data, (ushort)(0));
        }
        else
        {
            SpanWriter.WriteUInt16(ref data, (ushort)(obj.MediumQueue.Count));
            foreach (var item in obj.MediumQueue)
            {
                SpanWriter.WriteInt32(ref data, (int)(item));
            }
        }
        if (obj.LargeBag is null)
        {
            throw new System.ArgumentNullException(nameof(obj.LargeBag), "Fixed-size collections cannot be null.");
        }
        if (obj.LargeBag.Count != 8)
        {
            throw new System.InvalidOperationException($"Collection 'LargeBag' must have a size of 8 but was {obj.LargeBag.Count}.");
        }
        foreach (var item in obj.LargeBag)
        {
            SpanWriter.WriteInt64(ref data, (long)(item));
        }
        return originalData.Length - data.Length;
    }

    public static void Serialize(EnumerationTypesPacket obj, System.IO.Stream stream)
    {
        if (obj.Numbers is null)
        {
            StreamWriter.WriteInt32(stream, (int)(0));
        }
        else
        {
            StreamWriter.WriteInt32(stream, (int)(obj.Numbers.Count));
            for (int i = 0; i < obj.Numbers.Count; i++)
            {
                StreamWriter.WriteInt32(stream, (int)(obj.Numbers[i]));
            }
        }
        if (obj.Names is null)
        {
            StreamWriter.WriteInt32(stream, (int)(0));
        }
        else
        {
            StreamWriter.WriteInt32(stream, (int)(obj.Names.Count()));
            foreach (var item in obj.Names)
            {
                StreamWriter.WriteString(stream, item);
            }
        }
        if (obj.Data is null)
        {
            StreamWriter.WriteInt32(stream, (int)(0));
        }
        else
        {
            StreamWriter.WriteInt32(stream, (int)(obj.Data.Count()));
            StreamWriter.WriteBytes(stream, obj.Data);
        }
        if (obj.Data1 is null)
        {
            StreamWriter.WriteInt32(stream, (int)(0));
        }
        else
        {
            StreamWriter.WriteInt32(stream, (int)(obj.Data1.Count));
            StreamWriter.WriteBytes(stream, obj.Data1);
        }
        if (obj.Values is null)
        {
            StreamWriter.WriteInt32(stream, (int)(0));
        }
        else
        {
            StreamWriter.WriteInt32(stream, (int)(obj.Values.Count));
            foreach (var item in obj.Values)
            {
                StreamWriter.WriteSingle(stream, (float)(item));
            }
        }
        if (obj.UniqueIds is null)
        {
            StreamWriter.WriteInt32(stream, (int)(0));
        }
        else
        {
            StreamWriter.WriteInt32(stream, (int)(obj.UniqueIds.Count));
            foreach (var item in obj.UniqueIds)
            {
                StreamWriter.WriteInt64(stream, (long)(item));
            }
        }
        if (obj.ProcessingQueue is null)
        {
            StreamWriter.WriteInt32(stream, (int)(0));
        }
        else
        {
            StreamWriter.WriteInt32(stream, (int)(obj.ProcessingQueue.Count));
            foreach (var item in obj.ProcessingQueue)
            {
                StreamWriter.WriteUInt16(stream, (ushort)(item));
            }
        }
        if (obj.ProcessingStack is null)
        {
            StreamWriter.WriteInt32(stream, (int)(0));
        }
        else
        {
            StreamWriter.WriteInt32(stream, (int)(obj.ProcessingStack.Count));
            foreach (var item in obj.ProcessingStack)
            {
                StreamWriter.WriteUInt32(stream, (uint)(item));
            }
        }
        if (obj.ArrayData is null)
        {
            StreamWriter.WriteInt32(stream, (int)(0));
        }
        else
        {
            StreamWriter.WriteInt32(stream, (int)(obj.ArrayData.Length));
            for (int i = 0; i < obj.ArrayData.Length; i++)
            {
                StreamWriter.WriteInt32(stream, (int)(obj.ArrayData[i]));
            }
        }
        if (obj.Measurements is null)
        {
            StreamWriter.WriteInt32(stream, (int)(0));
        }
        else
        {
            StreamWriter.WriteInt32(stream, (int)(obj.Measurements.Count()));
            foreach (var item in obj.Measurements)
            {
                StreamWriter.WriteDouble(stream, (double)(item));
            }
        }
        if (obj.Flags is null)
        {
            StreamWriter.WriteInt32(stream, (int)(0));
        }
        else
        {
            StreamWriter.WriteInt32(stream, (int)(obj.Flags.Count));
            foreach (var item in obj.Flags)
            {
                StreamWriter.WriteBoolean(stream, (bool)(item));
            }
        }
        if (obj.ObservableData is null)
        {
            StreamWriter.WriteInt32(stream, (int)(0));
        }
        else
        {
            StreamWriter.WriteInt32(stream, (int)(obj.ObservableData.Count));
            foreach (var item in obj.ObservableData)
            {
                StreamWriter.WriteInt16(stream, (short)(item));
            }
        }
        if (obj.Characters is null)
        {
            StreamWriter.WriteInt32(stream, (int)(0));
        }
        else
        {
            StreamWriter.WriteInt32(stream, (int)(obj.Characters.Count));
            foreach (var item in obj.Characters)
            {
                StreamWriter.WriteUInt16(stream, (ushort)(item));
            }
        }
        if (obj.SortedValues is null)
        {
            StreamWriter.WriteInt32(stream, (int)(0));
        }
        else
        {
            StreamWriter.WriteInt32(stream, (int)(obj.SortedValues.Count));
            foreach (var item in obj.SortedValues)
            {
                StreamWriter.WriteInt64(stream, (long)(item));
            }
        }
        if (obj.SmallSet is null)
        {
            StreamWriter.WriteByte(stream, (byte)(0));
        }
        else
        {
            StreamWriter.WriteByte(stream, (byte)(obj.SmallSet.Count));
            foreach (var item in obj.SmallSet)
            {
                StreamWriter.WriteString(stream, item);
            }
        }
        if (obj.MediumQueue is null)
        {
            StreamWriter.WriteUInt16(stream, (ushort)(0));
        }
        else
        {
            StreamWriter.WriteUInt16(stream, (ushort)(obj.MediumQueue.Count));
            foreach (var item in obj.MediumQueue)
            {
                StreamWriter.WriteInt32(stream, (int)(item));
            }
        }
        if (obj.LargeBag is null)
        {
            throw new System.ArgumentNullException(nameof(obj.LargeBag), "Fixed-size collections cannot be null.");
        }
        if (obj.LargeBag.Count != 8)
        {
            throw new System.InvalidOperationException($"Collection 'LargeBag' must have a size of 8 but was {obj.LargeBag.Count}.");
        }
        foreach (var item in obj.LargeBag)
        {
            StreamWriter.WriteInt64(stream, (long)(item));
        }
    }
}

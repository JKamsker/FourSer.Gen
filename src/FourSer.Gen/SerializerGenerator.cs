using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using FourSer.Gen.Models;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using FourSer.Gen.CodeGenerators;
using FourSer.Gen.Helpers;
using System.Collections.Immutable;

namespace FourSer.Gen;

[Generator]
public class SerializerGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(AddHelpers);

        var typesToGenerate = context.SyntaxProvider
            .ForAttributeWithMetadataName
            (
                "FourSer.Contracts.GenerateSerializerAttribute",
                predicate: (node, _) => node is ClassDeclarationSyntax or StructDeclarationSyntax,
                transform: TypeInfoProvider.GetSemanticTargetForGeneration
            );

        var nonNullableTypes = typesToGenerate.Where(static m => m is not null);

        context.RegisterSourceOutput
        (
            nonNullableTypes,
            (spc, source) => Execute(spc, source!.Value)
        );
    }

    private static void Execute(SourceProductionContext context, TypeToGenerate typeToGenerate)
    {
        var sb = new StringBuilder();

        GenerateFileHeader(sb, typeToGenerate);
        GenerateClassDeclaration(sb, typeToGenerate);

        PacketSizeGenerator.GenerateGetPacketSize(sb, typeToGenerate);
        sb.AppendLine();

        if (typeToGenerate.Constructor is { ShouldGenerate: true } ctor)
        {
            if (!ctor.Parameters.IsEmpty)
            {
                GenerateConstructor(sb, typeToGenerate, ctor);
                sb.AppendLine();
            }

            if (!ctor.HasPublicParameterlessConstructor)
            {
                GenerateParameterlessConstructor(sb, typeToGenerate);
                sb.AppendLine();
            }
        }

        DeserializationGenerator.GenerateDeserialize(sb, typeToGenerate);
        sb.AppendLine();

        SerializationGenerator.GenerateSerialize(sb, typeToGenerate);

        if (!typeToGenerate.NestedTypes.IsEmpty)
        {
            NestedTypeGenerator.GenerateNestedTypes(sb, typeToGenerate.NestedTypes);
        }

        sb.AppendLine("}");

        // Namespaces can contain '.', which is not allowed in file names.
        var hintName = $"{typeToGenerate.Namespace}.{typeToGenerate.Name}".Replace('.', '_');
        context.AddSource($"{hintName}.g.cs", sb.ToString());
    }

    private static void GenerateFileHeader(StringBuilder sb, TypeToGenerate typeToGenerate)
    {
        sb.AppendLine($"// <auto-generated/>");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Buffers.Binary;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine("using System.Text;");
        sb.AppendLine("using FourSer.Contracts;");
        sb.AppendLine($"using System.IO;");
        sb.AppendLine($"using FourSer.Gen.Helpers;");
        sb.AppendLine();
        sb.AppendLine($"namespace {typeToGenerate.Namespace};");
        sb.AppendLine();
    }

    private static void GenerateClassDeclaration(StringBuilder sb, TypeToGenerate typeToGenerate)
    {
        var typeKeyword = typeToGenerate.IsValueType ? "struct" : "class";
        sb.AppendLine($"public partial {typeKeyword} {typeToGenerate.Name} : ISerializable<{typeToGenerate.Name}>");
        sb.AppendLine("{");
    }

    internal static void GenerateConstructor(StringBuilder sb, TypeToGenerate typeToGenerate, Models.ConstructorInfo ctor)
    {
        var parameters = string.Join(", ", ctor.Parameters.Select(p => $"{p.TypeName} {StringExtensions.ToCamelCase(p.Name)}"));
        sb.AppendLine($"    private {typeToGenerate.Name}({parameters})");
        sb.AppendLine("    {");

        foreach (var parameter in ctor.Parameters)
        {
            sb.AppendLine($"        this.{parameter.Name} = {StringExtensions.ToCamelCase(parameter.Name)};");
        }

        sb.AppendLine("    }");
    }

    internal static void GenerateParameterlessConstructor(StringBuilder sb, TypeToGenerate typeToGenerate)
    {
        if (typeToGenerate.IsValueType) return;

        sb.AppendLine($"    public {typeToGenerate.Name}()");
        sb.AppendLine("    {");

        foreach (var member in typeToGenerate.Members)
        {
            if (member.IsReadOnly) continue;

            sb.AppendLine($"        this.{member.Name} = default;");
        }
        sb.AppendLine("    }");
    }

    private static void AddHelpers(IncrementalGeneratorPostInitializationContext context)
    {
        var assembly = Assembly.GetExecutingAssembly();
        var names = assembly.GetManifestResourceNames()
            .Where(name => name.StartsWith("FourSer.Gen.Resources.Code."));

        foreach (var file in names)
        {
            using var stream = assembly.GetManifestResourceStream(file);
            if (stream is null) continue;

            using var reader = new StreamReader(stream);
            var source = reader.ReadToEnd();
            context.AddSource(file, source);
        }
    }
}
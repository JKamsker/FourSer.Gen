using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using FourSer.Gen.Models;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using FourSer.Gen.CodeGenerators;

namespace FourSer.Gen;

[Generator]
public class SerializerGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(AddHelpers);

        var typesToGenerate = context.SyntaxProvider
            .ForAttributeWithMetadataName
            (
                "FourSer.Contracts.GenerateSerializerAttribute",
                predicate: (node, _) => node is ClassDeclarationSyntax or StructDeclarationSyntax,
                transform: TypeInfoProvider.GetSemanticTargetForGeneration
            );

        var nonNullableTypes = typesToGenerate.Where(static m => m is not null);

        context.RegisterSourceOutput
        (
            nonNullableTypes,
            (spc, source) => Execute(spc, source!.Value)
        );
    }

    private static void Execute(SourceProductionContext context, TypeToGenerate typeToGenerate)
    {
        var sb = new StringBuilder();
        GenerateFileHeader(sb, typeToGenerate);

        GenerateType(sb, typeToGenerate);

        context.AddSource($"{typeToGenerate.Name}.g.cs", sb.ToString());
    }

    private static void GenerateType(StringBuilder sb, TypeToGenerate typeToGenerate)
    {
        GenerateClassDeclaration(sb, typeToGenerate);

        PacketSizeGenerator.GenerateGetPacketSize(sb, typeToGenerate);
        sb.AppendLine();

        DeserializationGenerator.GenerateDeserialize(sb, typeToGenerate);
        sb.AppendLine();

        SerializationGenerator.GenerateSerialize(sb, typeToGenerate);

        if (!typeToGenerate.NestedTypes.IsEmpty)
        {
            foreach (var nestedType in typeToGenerate.NestedTypes)
            {
                GenerateType(sb, nestedType);
            }
        }

        sb.AppendLine("}");
    }

    private static void GenerateFileHeader(StringBuilder sb, TypeToGenerate typeToGenerate)
    {
        sb.AppendLine($"// <auto-generated/>");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Buffers.Binary;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine("using System.Text;");
        sb.AppendLine("using FourSer.Contracts;");
        sb.AppendLine($"using System.IO;");
        sb.AppendLine($"using FourSer.Gen.Helpers;");
        sb.AppendLine();
        sb.AppendLine($"namespace {typeToGenerate.Namespace};");
        sb.AppendLine();
    }

    private static void GenerateClassDeclaration(StringBuilder sb, TypeToGenerate typeToGenerate)
    {
        var typeKeyword = typeToGenerate.IsValueType ? "struct" : "class";
        sb.AppendLine($"public partial {typeKeyword} {typeToGenerate.Name} : ISerializable<{typeToGenerate.Name}>");
        sb.AppendLine("{");
    }

    private static void AddHelpers(IncrementalGeneratorPostInitializationContext context)
    {
        var assembly = Assembly.GetExecutingAssembly();
        var names = assembly.GetManifestResourceNames()
            .Where(name => name.StartsWith("FourSer.Gen.Resources.Code."));

        foreach (var file in names)
        {
            using var stream = assembly.GetManifestResourceStream(file);
            if (stream is null) continue;

            using var reader = new StreamReader(stream);
            var source = reader.ReadToEnd();
            context.AddSource(file, source);
        }
    }
}
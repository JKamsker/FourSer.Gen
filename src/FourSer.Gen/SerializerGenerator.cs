using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using FourSer.Gen.Models;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using FourSer.Gen.CodeGenerators;
using FourSer.Gen.Helpers;
using System.Collections.Immutable;

namespace FourSer.Gen;

[Generator]
public class SerializerGenerator : IIncrementalGenerator
{
    private static readonly DiagnosticDescriptor s_invalidCollectionTypeArgument = new
    (
        "FSSG001",
        "Invalid collection type argument",
        "The type '{0}' in the collection '{1}' must have the [GenerateSerializer] attribute because it is not a primitive type.",
        "Usage",
        DiagnosticSeverity.Warning,
        true
    );

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(AddHelpers);

        var typesToGenerate = context.SyntaxProvider
            .ForAttributeWithMetadataName
            (
                "FourSer.Contracts.GenerateSerializerAttribute",
                predicate: (node, _) => node is ClassDeclarationSyntax or StructDeclarationSyntax or RecordDeclarationSyntax,
                transform: TypeInfoProvider.GetSemanticTargetForGeneration
            );

        var nonNullableTypes = typesToGenerate.Where(static m => m is not null);

        context.RegisterSourceOutput
        (
            nonNullableTypes,
            (spc, source) => Execute(spc, source!.Value)
        );
    }

    private static void Execute(SourceProductionContext context, TypeToGenerate typeToGenerate)
    {
        if (HasInvalidCollection(context, typeToGenerate))
        {
            return;
        }

        var sb = new StringBuilder();

        GenerateFileHeader(sb, typeToGenerate);
        GenerateClassDeclaration(sb, typeToGenerate);

        PacketSizeGenerator.GenerateGetPacketSize(sb, typeToGenerate);
        sb.AppendLine();

        if (typeToGenerate.Constructor is { ShouldGenerate: true } ctor && !typeToGenerate.IsRecord)
        {
            if (!ctor.Parameters.IsEmpty)
            {
                GenerateConstructor(sb, typeToGenerate, ctor);
                sb.AppendLine();
            }

            if (!ctor.HasParameterlessConstructor)
            {
                GenerateParameterlessConstructor(sb, typeToGenerate);
                sb.AppendLine();
            }
        }

        DeserializationGenerator.GenerateDeserialize(sb, typeToGenerate);
        sb.AppendLine();

        SerializationGenerator.GenerateSerialize(sb, typeToGenerate);

        if (!typeToGenerate.NestedTypes.IsEmpty)
        {
            NestedTypeGenerator.GenerateNestedTypes(sb, typeToGenerate.NestedTypes);
        }

        sb.Append('}').AppendLine();

        // Namespaces can contain '.', which is not allowed in file names.
        var hintName = $"{typeToGenerate.Namespace}.{typeToGenerate.Name}".Replace('.', '_');
        context.AddSource($"{hintName}.g.cs", sb.ToString());
    }

    private static void GenerateFileHeader(StringBuilder sb, TypeToGenerate typeToGenerate)
    {
        sb.AppendLine($"// <auto-generated/>");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Buffers.Binary;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine("using System.Text;");
        sb.AppendLine("using FourSer.Contracts;");
        sb.AppendLine($"using System.IO;");
        sb.AppendLine($"using FourSer.Gen.Helpers;");
        sb.AppendLine();
        sb.AppendLine($"namespace {typeToGenerate.Namespace};");
        sb.AppendLine();
    }

    private static void GenerateClassDeclaration(StringBuilder sb, TypeToGenerate typeToGenerate)
    {
        var typeKeyword = typeToGenerate.IsValueType ? "struct" : "class";
        if (typeToGenerate.IsRecord)
        {
            typeKeyword = $"record {typeKeyword}";
        }
        sb.AppendLine($"public partial {typeKeyword} {typeToGenerate.Name} : ISerializable<{typeToGenerate.Name}>");
        sb.Append('{').AppendLine();
    }

    internal static void GenerateConstructor(StringBuilder sb, TypeToGenerate typeToGenerate, Models.ConstructorInfo ctor)
    {
        sb.Append($"    private {typeToGenerate.Name}(");

        bool first = true;
        foreach (var p in ctor.Parameters)
        {
            if (!first)
            {
                sb.Append(", ");
            }
            sb.Append(p.TypeName);
            sb.Append(' ');
            sb.Append(StringExtensions.ToCamelCase(p.Name));
            first = false;
        }

        sb.AppendLine(")");
        sb.AppendLine("    {");

        foreach (var parameter in ctor.Parameters)
        {
            sb.AppendLine($"        this.{parameter.Name} = {StringExtensions.ToCamelCase(parameter.Name)};");
        }

        sb.AppendLine("    }");
    }

    internal static void GenerateParameterlessConstructor(StringBuilder sb, TypeToGenerate typeToGenerate)
    {
        if (typeToGenerate.IsValueType) return;

        sb.AppendLine($"    public {typeToGenerate.Name}()");
        sb.AppendLine("    {");

        foreach (var member in typeToGenerate.Members)
        {
            if (member.IsReadOnly) continue;

            sb.AppendLine($"        this.{member.Name} = default;");
        }
        sb.AppendLine("    }");
    }

    private static bool HasInvalidCollection(SourceProductionContext context, TypeToGenerate typeToGenerate)
    {
        bool hasError = false;
        foreach (var member in typeToGenerate.Members)
        {
            if (!member.IsCollection || member.CollectionTypeInfo is null)
            {
                continue;
            }

            var collectionTypeInfo = member.CollectionTypeInfo.Value;
            if (collectionTypeInfo.IsElementUnmanagedType || collectionTypeInfo.IsElementStringType ||
                collectionTypeInfo.HasElementGenerateSerializerAttribute)
            {
                continue;
            }

            var location = Location.Create
            (
                member.Location.FilePath,
                new Microsoft.CodeAnalysis.Text.TextSpan(member.Location.Start, member.Location.End - member.Location.Start),
                new Microsoft.CodeAnalysis.Text.LinePositionSpan
                (
                    new Microsoft.CodeAnalysis.Text.LinePosition(member.Location.Start, 0),
                    new Microsoft.CodeAnalysis.Text.LinePosition(member.Location.End, 0)
                )
            );

            context.ReportDiagnostic(Diagnostic.Create(s_invalidCollectionTypeArgument, location,
                collectionTypeInfo.ElementTypeName, member.Name));

            hasError = true;
        }

        return hasError;
    }

    private static void AddHelpers(IncrementalGeneratorPostInitializationContext context)
    {
        var assembly = Assembly.GetExecutingAssembly();
        var names = assembly.GetManifestResourceNames();

        foreach (var file in names)
        {
            if (!file.StartsWith("FourSer.Gen.Resources.Code."))
            {
                continue;
            }

            using var stream = assembly.GetManifestResourceStream(file);
            if (stream is null) continue;

            using var reader = new StreamReader(stream);
            var source = reader.ReadToEnd();
            context.AddSource(file, source);
        }
    }
}
using System.Text;
using Serializer.Generator.CodeGenerators;
using Serializer.Generator.Models;

namespace Serializer.Generator;

/// <summary>
/// Handles the generation of complete source files for serializable types
/// </summary>
public static class SourceGenerator
{
    public static string GenerateSource(TypeToGenerate typeToGenerate)
    {
        var sb = new StringBuilder();
        
        GenerateFileHeader(sb, typeToGenerate);
        GenerateClassDeclaration(sb, typeToGenerate);
        
        PacketSizeGenerator.GenerateGetPacketSize(sb, typeToGenerate);
        sb.AppendLine();
        
        DeserializationGenerator.GenerateDeserialize(sb, typeToGenerate);
        sb.AppendLine();
        
        SerializationGenerator.GenerateSerialize(sb, typeToGenerate);

        if (!typeToGenerate.NestedTypes.IsEmpty)
        {
            NestedTypeGenerator.GenerateNestedTypes(sb, typeToGenerate.NestedTypes);
        }

        sb.AppendLine("}");
        return sb.ToString();
    }

    private static void GenerateFileHeader(StringBuilder sb, TypeToGenerate typeToGenerate)
    {
        sb.AppendLine($"// <auto-generated/>");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Buffers.Binary;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine("using System.Text;");
        sb.AppendLine("using Serializer.Contracts;");
        sb.AppendLine($"using System.IO;");
        sb.AppendLine($"using Serializer.Generator.Helpers;");
        sb.AppendLine();
        sb.AppendLine($"namespace {typeToGenerate.Namespace};");
        sb.AppendLine();
    }

    private static void GenerateClassDeclaration(StringBuilder sb, TypeToGenerate typeToGenerate)
    {
        var typeKeyword = typeToGenerate.IsValueType ? "struct" : "class";
        sb.AppendLine($"public partial {typeKeyword} {typeToGenerate.Name} : ISerializable<{typeToGenerate.Name}>");
        sb.AppendLine("{");
    }
}
using Microsoft.CodeAnalysis;
using System.Collections.Immutable;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System;

namespace Serializer.Generator;

[Generator]
public class SerializerGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var typeDeclarations = context.SyntaxProvider
            .ForAttributeWithMetadataName
            (
                "Serializer.Contracts.GenerateSerializerAttribute",
                predicate: (node, _) => node is ClassDeclarationSyntax or StructDeclarationSyntax,
                transform: (context, _) => (TypeDeclarationSyntax)context.TargetNode
            );

        context.RegisterSourceOutput
        (
            context.CompilationProvider.Combine(typeDeclarations.Collect()),
            (spc, source) => Execute(source.Left, source.Right, spc)
        );
    }

    private static void Execute
        (Compilation compilation, ImmutableArray<TypeDeclarationSyntax> types, SourceProductionContext context)
    {
        if (types.IsDefaultOrEmpty)
        {
            return;
        }

        foreach (var typeDeclaration in types.Distinct())
        {
            var semanticModel = compilation.GetSemanticModel(typeDeclaration.SyntaxTree);
            var typeSymbol = semanticModel.GetDeclaredSymbol(typeDeclaration);

            if (typeSymbol is not INamedTypeSymbol namedTypeSymbol)
            {
                continue;
            }

            var members = namedTypeSymbol.GetMembers()
                .Where
                (
                    m =>
                        (m.Kind == SymbolKind.Property && ((IPropertySymbol)m).SetMethod != null) ||
                        (m.Kind == SymbolKind.Field && m.DeclaredAccessibility == Accessibility.Public
                            && !((IFieldSymbol)m).IsReadOnly)
                )
                .OrderBy(m => m.Locations.First().SourceSpan.Start)
                .ToList();

            var classToGenerate = new ClassToGenerate(namedTypeSymbol.Name,
                namedTypeSymbol.ContainingNamespace.ToDisplayString(), members, namedTypeSymbol.IsValueType);

            var source = GenerateSource(classToGenerate, namedTypeSymbol);
            context.AddSource($"{classToGenerate.Name}.g.cs", source);
        }
    }

    private static ITypeSymbol GetMemberType(ISymbol member)
    {
        return member switch
        {
            IPropertySymbol property => property.Type,
            IFieldSymbol field => field.Type,
            _ => throw new ArgumentException($"Unsupported member type: {member.GetType()}")
        };
    }

    private static string GetTypeReference(ITypeSymbol typeSymbol, INamedTypeSymbol containingType)
    {
        // If the type is not nested, use the simple name
        if (typeSymbol.ContainingType == null)
        {
            return typeSymbol.Name;
        }

        // If the type is nested within the current class being generated
        if (SymbolEqualityComparer.Default.Equals(typeSymbol.ContainingType, containingType))
        {
            return $"{containingType.Name}.{typeSymbol.Name}";
        }

        // If the type is nested within a different class, use fully qualified name
        // Handle multiple levels of nesting by using ToDisplayString
        return typeSymbol.ToDisplayString();
    }

    private static string GenerateSource(ClassToGenerate classToGenerate, INamedTypeSymbol namedTypeSymbol)
    {
        var sb = new StringBuilder();
        sb.AppendLine($"// <auto-generated/>");
        sb.AppendLine($"using System;");
        sb.AppendLine($"using System.Collections.Generic;");
        sb.AppendLine($"using System.Text;");
        sb.AppendLine($"using Serializer.Contracts;");
        sb.AppendLine($"using FourServerProxy.HighPerformance.Extensions;");
        sb.AppendLine();
        sb.AppendLine($"namespace {classToGenerate.Namespace};");
        sb.AppendLine();
        var typeKeyword = classToGenerate.IsValueType ? "struct" : "class";
        sb.AppendLine(
            $"public partial {typeKeyword} {classToGenerate.Name} : ISerializable<{classToGenerate.Name}>");
        sb.AppendLine("{");
        sb.AppendLine($"    public static int GetPacketSize({classToGenerate.Name} obj)");
        sb.AppendLine("    {");
        sb.AppendLine("        var size = 0;");
        foreach (var member in classToGenerate.Members)
        {
            var memberType = GetMemberType(member);
            var attribute = member.GetAttributes().FirstOrDefault(a => a.AttributeClass?.Name == "SerializeCollectionAttribute");
            if (attribute != null && memberType is INamedTypeSymbol listTypeSymbol && listTypeSymbol.OriginalDefinition.ToDisplayString()
                == "System.Collections.Generic.List<T>")
            {
                var typeArgument = listTypeSymbol.TypeArguments[0];
                var countSizeReference = attribute?.NamedArguments.FirstOrDefault
                        (arg => arg.Key == "CountSizeReference")
                    .Value.Value?.ToString();
                var countType = attribute?.NamedArguments.FirstOrDefault
                        (arg => arg.Key == "CountType")
                    .Value.Value as ITypeSymbol;
                var countSize = attribute?.NamedArguments.FirstOrDefault(arg => arg.Key == "CountSize").Value.Value as int?;

                if (string.IsNullOrEmpty(countSizeReference))
                {
                    if (countType != null)
                    {
                        sb.AppendLine($"        size += sizeof({countType.ToDisplayString()}); // Count size for {member.Name}");
                    }
                    else if (countSize.HasValue && countSize != -1)
                    {
                        sb.AppendLine($"        size += {countSize.Value}; // Count size for {member.Name} (in bits)");
                    }
                    else
                    {
                        sb.AppendLine($"        size += sizeof(int); // Default count size for {member.Name}");
                    }
                }

                if (typeArgument.IsUnmanagedType)
                {
                    sb.AppendLine($"        size += obj.{member.Name}.Count * sizeof({typeArgument.ToDisplayString()});");
                }
                else
                {
                    sb.AppendLine($"        foreach(var item in obj.{member.Name})");
                    sb.AppendLine("        {");
                    sb.AppendLine($"            size += {GetTypeReference(typeArgument, namedTypeSymbol)}.GetPacketSize(item);");
                    sb.AppendLine("        }");
                }
            }
            else if (memberType.GetAttributes()
                     .Any(a => a.AttributeClass?.ToDisplayString() == "Serializer.Contracts.GenerateSerializerAttribute"))
            {
                sb.AppendLine($"        size += {memberType.Name}.GetPacketSize(obj.{member.Name});");
            }
            else if (memberType.SpecialType == SpecialType.System_String)
            {
                sb.AppendLine($"        size += sizeof(int); // Size for string length");
                sb.AppendLine($"        size += System.Text.Encoding.UTF8.GetByteCount(obj.{member.Name});");
            }
            else if (memberType.IsUnmanagedType)
            {
                sb.AppendLine
                    ($"        size += sizeof({memberType.ToDisplayString()}); // Size for unmanaged type {member.Name}");
            }
        }

        sb.AppendLine("        return size;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine($"    public static {classToGenerate.Name} Deserialize(ReadOnlySpan<byte> data, out int bytesRead)");
        sb.AppendLine("    {");
        sb.AppendLine($"        bytesRead = 0;");
        sb.AppendLine($"        var originalData = data;");
        sb.AppendLine($"        var obj = new {classToGenerate.Name}();");
        foreach (var member in classToGenerate.Members)
        {
            var memberType = GetMemberType(member);
            var attribute = member.GetAttributes().FirstOrDefault(a => a.AttributeClass?.Name == "SerializeCollectionAttribute");
            if (attribute != null && memberType is INamedTypeSymbol listTypeSymbol && listTypeSymbol.OriginalDefinition.ToDisplayString()
                == "System.Collections.Generic.List<T>")
            {
                var typeArgument = listTypeSymbol.TypeArguments[0];
                var countSizeReference = attribute?.NamedArguments.FirstOrDefault
                        (arg => arg.Key == "CountSizeReference")
                    .Value.Value?.ToString();
                var countType = attribute?.NamedArguments.FirstOrDefault
                        (arg => arg.Key == "CountType")
                    .Value.Value as ITypeSymbol;
                var countSize = attribute?.NamedArguments.FirstOrDefault(arg => arg.Key == "CountSize").Value.Value as int?;

                sb.AppendLine($"        var {member.Name}Count = 0;");
                if (!string.IsNullOrEmpty(countSizeReference))
                {
                    sb.AppendLine($"        {member.Name}Count = (int)obj.{countSizeReference};");
                }
                else if (countType != null)
                {
                    sb.AppendLine($"        {member.Name}Count = data.Read{countType.Name}();");
                }
                else if (countSize.HasValue && countSize != -1)
                {
                    sb.AppendLine($"        {member.Name}Count = data.ReadInt{countSize * 8}();");
                }
                else
                {
                    sb.AppendLine($"        {member.Name}Count = data.ReadInt32();");
                }

                sb.AppendLine
                (
                    $"        obj.{member.Name} = new System.Collections.Generic.List<{typeArgument.ToDisplayString()}>({member.Name}Count);"
                );
                sb.AppendLine($"        for (int i = 0; i < {member.Name}Count; i++)");
                sb.AppendLine("        {");
                if (typeArgument.IsUnmanagedType)
                {
                    sb.AppendLine($"            obj.{member.Name}.Add(data.Read{typeArgument.Name}());");
                }
                else
                {
                    sb.AppendLine
                        ($"            obj.{member.Name}.Add({GetTypeReference(typeArgument, namedTypeSymbol)}.Deserialize(data, out var itemBytesRead));");
                    sb.AppendLine($"            data = data.Slice(itemBytesRead);");
                }

                sb.AppendLine("        }");
            }
            else if (memberType.GetAttributes()
                     .Any(a => a.AttributeClass?.ToDisplayString() == "Serializer.Contracts.GenerateSerializerAttribute"))
            {
                sb.AppendLine($"        obj.{member.Name} = {memberType.Name}.Deserialize(data, out var nestedBytesRead);");
                sb.AppendLine($"        data = data.Slice(nestedBytesRead);");
            }
            else if (memberType.SpecialType == SpecialType.System_String)
            {
                sb.AppendLine($"        obj.{member.Name} = data.ReadString();");
            }
            else if (memberType.IsUnmanagedType)
            {
                sb.AppendLine($"        obj.{member.Name} = data.Read{memberType.Name}();");
            }
        }

        sb.AppendLine("        bytesRead = originalData.Length - data.Length;");
        sb.AppendLine("        return obj;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine($"    public static int Serialize({classToGenerate.Name} obj, Span<byte> data)");
        sb.AppendLine("    {");
        sb.AppendLine($"        var originalData = data;");
        foreach (var member in classToGenerate.Members)
        {
            var memberType = GetMemberType(member);
            var attribute = member.GetAttributes().FirstOrDefault(a => a.AttributeClass?.Name == "SerializeCollectionAttribute");
            if (attribute != null && memberType is INamedTypeSymbol listTypeSymbol && listTypeSymbol.OriginalDefinition.ToDisplayString()
                == "System.Collections.Generic.List<T>")
            {
                var typeArgument = listTypeSymbol.TypeArguments[0];
                var countSizeReference = attribute?.NamedArguments.FirstOrDefault
                        (arg => arg.Key == "CountSizeReference")
                    .Value.Value?.ToString();
                var countType = attribute?.NamedArguments.FirstOrDefault
                        (arg => arg.Key == "CountType")
                    .Value.Value as ITypeSymbol;
                var countSize = attribute?.NamedArguments.FirstOrDefault(arg => arg.Key == "CountSize").Value.Value as int?;

                if (string.IsNullOrEmpty(countSizeReference))
                {
                    if (countType != null)
                    {
                        sb.AppendLine($"        data.Write{countType.Name}((ushort)obj.{member.Name}.Count);");
                    }
                    else if (countSize.HasValue && countSize != -1)
                    {
                        sb.AppendLine($"        data.WriteInt{countSize * 8}((ushort)obj.{member.Name}.Count);");
                    }
                    else
                    {
                        sb.AppendLine($"        data.WriteInt32(obj.{member.Name}.Count);");
                    }
                }

                sb.AppendLine($"        for (int i = 0; i < obj.{member.Name}.Count; i++)");
                sb.AppendLine("        {");
                if (typeArgument.IsUnmanagedType)
                {
                    sb.AppendLine($"            data.Write{typeArgument.Name}(obj.{member.Name}[i]);");
                }
                else
                {
                    sb.AppendLine($"            var bytesWritten = {typeArgument.Name}.Serialize(obj.{member.Name}[i], data);");
                    sb.AppendLine($"            data = data.Slice(bytesWritten);");
                }

                sb.AppendLine("        }");
            }
            else if (memberType.GetAttributes()
                     .Any(a => a.AttributeClass?.ToDisplayString() == "Serializer.Contracts.GenerateSerializerAttribute"))
            {
                sb.AppendLine($"        var bytesWritten = {memberType.Name}.Serialize(obj.{member.Name}, data);");
                sb.AppendLine($"        data = data.Slice(bytesWritten);");
            }
            else if (memberType.SpecialType == SpecialType.System_String)
            {
                sb.AppendLine($"        data.WriteString(obj.{member.Name});");
            }
            else if (memberType.IsUnmanagedType)
            {
                sb.AppendLine($"        data.Write{memberType.Name}(obj.{member.Name});");
            }
        }

        sb.AppendLine("        return originalData.Length - data.Length;");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        return sb.ToString();
    }
}
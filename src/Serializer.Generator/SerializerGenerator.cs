using Microsoft.CodeAnalysis;
using System.Collections.Immutable;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System;

namespace Serializer.Generator;

[Generator]
public class SerializerGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var typeDeclarations = context.SyntaxProvider
            .ForAttributeWithMetadataName
            (
                "Serializer.Contracts.GenerateSerializerAttribute",
                predicate: (node, _) => node is ClassDeclarationSyntax or StructDeclarationSyntax,
                transform: (context, _) => (TypeDeclarationSyntax)context.TargetNode
            );

        context.RegisterSourceOutput
        (
            context.CompilationProvider.Combine(typeDeclarations.Collect()),
            (spc, source) => Execute(source.Left, source.Right, spc)
        );
    }

    private static void Execute
        (Compilation compilation, ImmutableArray<TypeDeclarationSyntax> types, SourceProductionContext context)
    {
        if (types.IsDefaultOrEmpty)
        {
            return;
        }

        // Group types by their containing type to handle nested classes properly
        var typeGroups = new Dictionary<INamedTypeSymbol, List<INamedTypeSymbol>>(SymbolEqualityComparer.Default);
        var allTypeSymbols = new List<INamedTypeSymbol>();

        foreach (var typeDeclaration in types.Distinct())
        {
            var semanticModel = compilation.GetSemanticModel(typeDeclaration.SyntaxTree);
            var typeSymbol = semanticModel.GetDeclaredSymbol(typeDeclaration);

            if (typeSymbol is not INamedTypeSymbol namedTypeSymbol)
            {
                continue;
            }

            allTypeSymbols.Add(namedTypeSymbol);

            // If this is a nested type, group it with its containing type
            if (namedTypeSymbol.ContainingType != null)
            {
                var containingType = namedTypeSymbol.ContainingType;
                if (!typeGroups.ContainsKey(containingType))
                {
                    typeGroups[containingType] = new List<INamedTypeSymbol>();
                }
                typeGroups[containingType].Add(namedTypeSymbol);
            }
        }

        foreach (var typeSymbol in allTypeSymbols)
        {
            // Skip nested types - they will be generated as part of their containing type
            if (typeSymbol.ContainingType != null)
            {
                continue;
            }

            var members = typeSymbol.GetMembers()
                .Where
                (
                    m =>
                        (m.Kind == SymbolKind.Property && ((IPropertySymbol)m).SetMethod != null) ||
                        (m.Kind == SymbolKind.Field && m.DeclaredAccessibility == Accessibility.Public
                            && !((IFieldSymbol)m).IsReadOnly)
                )
                .OrderBy(m => m.Locations.First().SourceSpan.Start)
                .ToList();

            var classToGenerate = new ClassToGenerate(typeSymbol.Name,
                typeSymbol.ContainingNamespace.ToDisplayString(), members, typeSymbol.IsValueType);

            // Get nested types that need to be generated
            var nestedTypes = typeGroups.ContainsKey(typeSymbol) ? typeGroups[typeSymbol] : new List<INamedTypeSymbol>();

            var source = GenerateSource(classToGenerate, typeSymbol, nestedTypes);
            context.AddSource($"{classToGenerate.Name}.g.cs", source);
        }
    }

    private static ITypeSymbol GetMemberType(ISymbol member)
    {
        return member switch
        {
            IPropertySymbol property => property.Type,
            IFieldSymbol field => field.Type,
            _ => throw new ArgumentException($"Unsupported member type: {member.GetType()}")
        };
    }

    private static string GetTypeReference(ITypeSymbol typeSymbol, INamedTypeSymbol containingType)
    {
        // If the type is not nested, use the simple name
        if (typeSymbol.ContainingType == null)
        {
            return typeSymbol.Name;
        }

        // If the type is nested within the current class being generated
        if (SymbolEqualityComparer.Default.Equals(typeSymbol.ContainingType, containingType))
        {
            return $"{containingType.Name}.{typeSymbol.Name}";
        }

        // If the type is nested within a different class, use fully qualified name
        // Handle multiple levels of nesting by using ToDisplayString
        return typeSymbol.ToDisplayString();
    }

    private static string GenerateSource(ClassToGenerate classToGenerate, INamedTypeSymbol namedTypeSymbol, List<INamedTypeSymbol>? nestedTypes = null)
    {
        var sb = new StringBuilder();
        sb.AppendLine($"// <auto-generated/>");
        sb.AppendLine($"using System;");
        sb.AppendLine($"using System.Collections.Generic;");
        sb.AppendLine($"using System.Text;");
        sb.AppendLine($"using Serializer.Contracts;");
        sb.AppendLine($"using FourServerProxy.HighPerformance.Extensions;");
        sb.AppendLine();
        sb.AppendLine($"namespace {classToGenerate.Namespace};");
        sb.AppendLine();
        var typeKeyword = classToGenerate.IsValueType ? "struct" : "class";
        sb.AppendLine(
            $"public partial {typeKeyword} {classToGenerate.Name} : ISerializable<{classToGenerate.Name}>");
        sb.AppendLine("{");
        sb.AppendLine($"    public static int GetPacketSize({classToGenerate.Name} obj)");
        sb.AppendLine("    {");
        sb.AppendLine("        var size = 0;");
        foreach (var member in classToGenerate.Members)
        {
            var memberType = GetMemberType(member);
            var collectionAttribute = member.GetAttributes().FirstOrDefault(a => a.AttributeClass?.Name == "SerializeCollectionAttribute");
            var polymorphicAttribute = member.GetAttributes().FirstOrDefault(a => a.AttributeClass?.Name == "SerializePolymorphicAttribute");
            
            if (collectionAttribute != null && memberType is INamedTypeSymbol listTypeSymbol && listTypeSymbol.OriginalDefinition.ToDisplayString()
                == "System.Collections.Generic.List<T>")
            {
                var typeArgument = listTypeSymbol.TypeArguments[0];
                var countSizeReference = collectionAttribute?.NamedArguments.FirstOrDefault
                        (arg => arg.Key == "CountSizeReference")
                    .Value.Value?.ToString();
                var countType = collectionAttribute?.NamedArguments.FirstOrDefault
                        (arg => arg.Key == "CountType")
                    .Value.Value as ITypeSymbol;
                var countSize = collectionAttribute?.NamedArguments.FirstOrDefault(arg => arg.Key == "CountSize").Value.Value as int?;

                if (string.IsNullOrEmpty(countSizeReference))
                {
                    if (countType != null)
                    {
                        sb.AppendLine($"        size += sizeof({countType.ToDisplayString()}); // Count size for {member.Name}");
                    }
                    else if (countSize.HasValue && countSize != -1)
                    {
                        sb.AppendLine($"        size += {countSize.Value}; // Count size for {member.Name} (in bits)");
                    }
                    else
                    {
                        sb.AppendLine($"        size += sizeof(int); // Default count size for {member.Name}");
                    }
                }

                if (typeArgument.IsUnmanagedType)
                {
                    sb.AppendLine($"        size += obj.{member.Name}.Count * sizeof({typeArgument.ToDisplayString()});");
                }
                else
                {
                    sb.AppendLine($"        foreach(var item in obj.{member.Name})");
                    sb.AppendLine("        {");
                    sb.AppendLine($"            size += {GetTypeReference(typeArgument, namedTypeSymbol)}.GetPacketSize(item);");
                    sb.AppendLine("        }");
                }
            }
            else if (polymorphicAttribute != null)
            {
                // Handle polymorphic size calculation
                var polymorphicOptions = member.GetAttributes()
                    .Where(a => a.AttributeClass?.Name == "PolymorphicOptionAttribute")
                    .ToList();

                var typeIdProperty = polymorphicAttribute.ConstructorArguments.FirstOrDefault().Value?.ToString();
                
                if (!string.IsNullOrEmpty(typeIdProperty) && polymorphicOptions.Any())
                {
                    sb.AppendLine($"        // Polymorphic size calculation for {member.Name} - infer type from actual object");
                    sb.AppendLine($"        switch (obj.{member.Name}.GetType().Name)");
                    sb.AppendLine("        {");
                    
                    foreach (var option in polymorphicOptions)
                    {
                        var id = option.ConstructorArguments[0].Value;
                        var type = option.ConstructorArguments[1].Value as ITypeSymbol;
                        if (type != null)
                        {
                            sb.AppendLine($"            case \"{type.Name}\":");
                            sb.AppendLine($"                size += {GetTypeReference(type, namedTypeSymbol)}.GetPacketSize(({GetTypeReference(type, namedTypeSymbol)})obj.{member.Name});");
                            sb.AppendLine("                break;");
                        }
                    }
                    
                    sb.AppendLine("            default:");
                    sb.AppendLine($"                throw new InvalidOperationException($\"Unknown polymorphic type: {{obj.{member.Name}.GetType().Name}}\");");
                    sb.AppendLine("        }");
                }
            }
            else if (memberType.GetAttributes()
                     .Any(a => a.AttributeClass?.ToDisplayString() == "Serializer.Contracts.GenerateSerializerAttribute"))
            {
                sb.AppendLine($"        size += {memberType.Name}.GetPacketSize(obj.{member.Name});");
            }
            else if (memberType.SpecialType == SpecialType.System_String)
            {
                sb.AppendLine($"        size += sizeof(int); // Size for string length");
                sb.AppendLine($"        size += System.Text.Encoding.UTF8.GetByteCount(obj.{member.Name});");
            }
            else if (memberType.IsUnmanagedType)
            {
                sb.AppendLine
                    ($"        size += sizeof({memberType.ToDisplayString()}); // Size for unmanaged type {member.Name}");
            }
        }

        sb.AppendLine("        return size;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine($"    public static {classToGenerate.Name} Deserialize(ReadOnlySpan<byte> data, out int bytesRead)");
        sb.AppendLine("    {");
        sb.AppendLine($"        bytesRead = 0;");
        sb.AppendLine($"        var originalData = data;");
        sb.AppendLine($"        var obj = new {classToGenerate.Name}();");
        foreach (var member in classToGenerate.Members)
        {
            var memberType = GetMemberType(member);
            var collectionAttribute = member.GetAttributes().FirstOrDefault(a => a.AttributeClass?.Name == "SerializeCollectionAttribute");
            var polymorphicAttribute = member.GetAttributes().FirstOrDefault(a => a.AttributeClass?.Name == "SerializePolymorphicAttribute");
            
            if (collectionAttribute != null && memberType is INamedTypeSymbol listTypeSymbol && listTypeSymbol.OriginalDefinition.ToDisplayString()
                == "System.Collections.Generic.List<T>")
            {
                var typeArgument = listTypeSymbol.TypeArguments[0];
                var countSizeReference = collectionAttribute?.NamedArguments.FirstOrDefault
                        (arg => arg.Key == "CountSizeReference")
                    .Value.Value?.ToString();
                var countType = collectionAttribute?.NamedArguments.FirstOrDefault
                        (arg => arg.Key == "CountType")
                    .Value.Value as ITypeSymbol;
                var countSize = collectionAttribute?.NamedArguments.FirstOrDefault(arg => arg.Key == "CountSize").Value.Value as int?;

                sb.AppendLine($"        var {member.Name}Count = 0;");
                if (!string.IsNullOrEmpty(countSizeReference))
                {
                    sb.AppendLine($"        {member.Name}Count = (int)obj.{countSizeReference};");
                }
                else if (countType != null)
                {
                    sb.AppendLine($"        {member.Name}Count = data.Read{countType.Name}();");
                }
                else if (countSize.HasValue && countSize != -1)
                {
                    sb.AppendLine($"        {member.Name}Count = data.ReadInt{countSize * 8}();");
                }
                else
                {
                    sb.AppendLine($"        {member.Name}Count = data.ReadInt32();");
                }

                sb.AppendLine
                (
                    $"        obj.{member.Name} = new System.Collections.Generic.List<{typeArgument.ToDisplayString()}>({member.Name}Count);"
                );
                sb.AppendLine($"        for (int i = 0; i < {member.Name}Count; i++)");
                sb.AppendLine("        {");
                if (typeArgument.IsUnmanagedType)
                {
                    sb.AppendLine($"            obj.{member.Name}.Add(data.Read{typeArgument.Name}());");
                }
                else
                {
                    sb.AppendLine
                        ($"            obj.{member.Name}.Add({GetTypeReference(typeArgument, namedTypeSymbol)}.Deserialize(data, out var itemBytesRead));");
                    sb.AppendLine($"            data = data.Slice(itemBytesRead);");
                }

                sb.AppendLine("        }");
            }
            else if (polymorphicAttribute != null)
            {
                // Handle polymorphic deserialization
                var polymorphicOptions = member.GetAttributes()
                    .Where(a => a.AttributeClass?.Name == "PolymorphicOptionAttribute")
                    .ToList();

                var typeIdProperty = polymorphicAttribute.ConstructorArguments.FirstOrDefault().Value?.ToString();
                
                if (!string.IsNullOrEmpty(typeIdProperty) && polymorphicOptions.Any())
                {
                    sb.AppendLine($"        // Polymorphic deserialization for {member.Name}");
                    sb.AppendLine($"        switch (obj.{typeIdProperty})");
                    sb.AppendLine("        {");
                    
                    foreach (var option in polymorphicOptions)
                    {
                        var id = option.ConstructorArguments[0].Value;
                        var type = option.ConstructorArguments[1].Value as ITypeSymbol;
                        if (type != null)
                        {
                            sb.AppendLine($"            case {id}:");
                            sb.AppendLine($"                obj.{member.Name} = {GetTypeReference(type, namedTypeSymbol)}.Deserialize(data, out var {member.Name}BytesRead{id});");
                            sb.AppendLine($"                data = data.Slice({member.Name}BytesRead{id});");
                            sb.AppendLine("                break;");
                        }
                    }
                    
                    sb.AppendLine("            default:");
                    sb.AppendLine($"                throw new InvalidOperationException($\"Unknown type ID: {{obj.{typeIdProperty}}}\");");
                    sb.AppendLine("        }");
                }
            }
            else if (memberType.GetAttributes()
                     .Any(a => a.AttributeClass?.ToDisplayString() == "Serializer.Contracts.GenerateSerializerAttribute"))
            {
                sb.AppendLine($"        obj.{member.Name} = {memberType.Name}.Deserialize(data, out var nestedBytesRead);");
                sb.AppendLine($"        data = data.Slice(nestedBytesRead);");
            }
            else if (memberType.SpecialType == SpecialType.System_String)
            {
                sb.AppendLine($"        obj.{member.Name} = data.ReadString();");
            }
            else if (memberType.IsUnmanagedType)
            {
                sb.AppendLine($"        obj.{member.Name} = data.Read{memberType.Name}();");
            }
        }

        sb.AppendLine("        bytesRead = originalData.Length - data.Length;");
        sb.AppendLine("        return obj;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine($"    public static int Serialize({classToGenerate.Name} obj, Span<byte> data)");
        sb.AppendLine("    {");
        sb.AppendLine($"        var originalData = data;");
        
        // Generate helper method to infer TypeId from polymorphic properties
        var polymorphicMembers = classToGenerate.Members
            .Where(m => m.GetAttributes().Any(a => a.AttributeClass?.Name == "SerializePolymorphicAttribute"))
            .ToList();
            
        if (polymorphicMembers.Any())
        {
            sb.AppendLine("        // Ensure TypeId properties are synchronized with actual object types");
            foreach (var polymorphicMember in polymorphicMembers)
            {
                var polymorphicAttribute = polymorphicMember.GetAttributes().FirstOrDefault(a => a.AttributeClass?.Name == "SerializePolymorphicAttribute");
                var polymorphicOptions = polymorphicMember.GetAttributes()
                    .Where(a => a.AttributeClass?.Name == "PolymorphicOptionAttribute")
                    .ToList();

                var typeIdProperty = polymorphicAttribute?.ConstructorArguments.FirstOrDefault().Value?.ToString();
                
                if (!string.IsNullOrEmpty(typeIdProperty) && polymorphicOptions.Any())
                {
                    sb.AppendLine($"        var actualType{polymorphicMember.Name} = obj.{polymorphicMember.Name}.GetType().Name;");
                    sb.AppendLine($"        switch (actualType{polymorphicMember.Name})");
                    sb.AppendLine("        {");
                    
                    foreach (var option in polymorphicOptions)
                    {
                        var id = option.ConstructorArguments[0].Value;
                        var type = option.ConstructorArguments[1].Value as ITypeSymbol;
                        if (type != null)
                        {
                            sb.AppendLine($"            case \"{type.Name}\":");
                            sb.AppendLine($"                obj.{typeIdProperty} = {id};");
                            sb.AppendLine("                break;");
                        }
                    }
                    
                    sb.AppendLine("            default:");
                    sb.AppendLine($"                throw new InvalidOperationException($\"Unknown polymorphic type: {{actualType{polymorphicMember.Name}}}\");");
                    sb.AppendLine("        }");
                }
            }
        }
        foreach (var member in classToGenerate.Members)
        {
            var memberType = GetMemberType(member);
            var collectionAttribute = member.GetAttributes().FirstOrDefault(a => a.AttributeClass?.Name == "SerializeCollectionAttribute");
            var polymorphicAttribute = member.GetAttributes().FirstOrDefault(a => a.AttributeClass?.Name == "SerializePolymorphicAttribute");
            
            if (collectionAttribute != null && memberType is INamedTypeSymbol listTypeSymbol && listTypeSymbol.OriginalDefinition.ToDisplayString()
                == "System.Collections.Generic.List<T>")
            {
                var typeArgument = listTypeSymbol.TypeArguments[0];
                var countSizeReference = collectionAttribute?.NamedArguments.FirstOrDefault
                        (arg => arg.Key == "CountSizeReference")
                    .Value.Value?.ToString();
                var countType = collectionAttribute?.NamedArguments.FirstOrDefault
                        (arg => arg.Key == "CountType")
                    .Value.Value as ITypeSymbol;
                var countSize = collectionAttribute?.NamedArguments.FirstOrDefault(arg => arg.Key == "CountSize").Value.Value as int?;

                if (string.IsNullOrEmpty(countSizeReference))
                {
                    if (countType != null)
                    {
                        sb.AppendLine($"        data.Write{countType.Name}((ushort)obj.{member.Name}.Count);");
                    }
                    else if (countSize.HasValue && countSize != -1)
                    {
                        sb.AppendLine($"        data.WriteInt{countSize * 8}((ushort)obj.{member.Name}.Count);");
                    }
                    else
                    {
                        sb.AppendLine($"        data.WriteInt32(obj.{member.Name}.Count);");
                    }
                }

                sb.AppendLine($"        for (int i = 0; i < obj.{member.Name}.Count; i++)");
                sb.AppendLine("        {");
                if (typeArgument.IsUnmanagedType)
                {
                    sb.AppendLine($"            data.Write{typeArgument.Name}(obj.{member.Name}[i]);");
                }
                else
                {
                    sb.AppendLine($"            var bytesWritten = {GetTypeReference(typeArgument, namedTypeSymbol)}.Serialize(obj.{member.Name}[i], data);");
                    sb.AppendLine($"            data = data.Slice(bytesWritten);");
                }

                sb.AppendLine("        }");
            }
            else if (polymorphicAttribute != null)
            {
                // Handle polymorphic serialization - TypeId already synchronized above
                var polymorphicOptions = member.GetAttributes()
                    .Where(a => a.AttributeClass?.Name == "PolymorphicOptionAttribute")
                    .ToList();

                var typeIdProperty = polymorphicAttribute.ConstructorArguments.FirstOrDefault().Value?.ToString();
                
                if (!string.IsNullOrEmpty(typeIdProperty) && polymorphicOptions.Any())
                {
                    sb.AppendLine($"        // Polymorphic serialization for {member.Name}");
                    sb.AppendLine($"        switch (obj.{typeIdProperty})");
                    sb.AppendLine("        {");
                    
                    foreach (var option in polymorphicOptions)
                    {
                        var id = option.ConstructorArguments[0].Value;
                        var type = option.ConstructorArguments[1].Value as ITypeSymbol;
                        if (type != null)
                        {
                            sb.AppendLine($"            case {id}:");
                            sb.AppendLine($"                var {member.Name}BytesWritten{id} = {GetTypeReference(type, namedTypeSymbol)}.Serialize(({GetTypeReference(type, namedTypeSymbol)})obj.{member.Name}, data);");
                            sb.AppendLine($"                data = data.Slice({member.Name}BytesWritten{id});");
                            sb.AppendLine("                break;");
                        }
                    }
                    
                    sb.AppendLine("            default:");
                    sb.AppendLine($"                throw new InvalidOperationException($\"Unknown type ID: {{obj.{typeIdProperty}}}\");");
                    sb.AppendLine("        }");
                }
            }
            else if (memberType.GetAttributes()
                     .Any(a => a.AttributeClass?.ToDisplayString() == "Serializer.Contracts.GenerateSerializerAttribute"))
            {
                sb.AppendLine($"        var bytesWritten = {memberType.Name}.Serialize(obj.{member.Name}, data);");
                sb.AppendLine($"        data = data.Slice(bytesWritten);");
            }
            else if (memberType.SpecialType == SpecialType.System_String)
            {
                sb.AppendLine($"        data.WriteString(obj.{member.Name});");
            }
            else if (memberType.IsUnmanagedType)
            {
                sb.AppendLine($"        data.Write{memberType.Name}(obj.{member.Name});");
            }
        }

        sb.AppendLine("        return originalData.Length - data.Length;");
        sb.AppendLine("    }");

        // Generate nested types
        if (nestedTypes != null && nestedTypes.Any())
        {
            foreach (var nestedType in nestedTypes)
            {
                var nestedMembers = nestedType.GetMembers()
                    .Where
                    (
                        m =>
                            (m.Kind == SymbolKind.Property && ((IPropertySymbol)m).SetMethod != null) ||
                            (m.Kind == SymbolKind.Field && m.DeclaredAccessibility == Accessibility.Public
                                && !((IFieldSymbol)m).IsReadOnly)
                    )
                    .OrderBy(m => m.Locations.First().SourceSpan.Start)
                    .ToList();

                var nestedClassToGenerate = new ClassToGenerate(nestedType.Name,
                    nestedType.ContainingNamespace.ToDisplayString(), nestedMembers, nestedType.IsValueType);

                sb.AppendLine();
                sb.AppendLine($"    public partial {(nestedType.IsValueType ? "struct" : "class")} {nestedType.Name} : ISerializable<{nestedType.Name}>");
                sb.AppendLine("    {");
                
                // Generate GetPacketSize for nested type
                sb.AppendLine($"        public static int GetPacketSize({nestedType.Name} obj)");
                sb.AppendLine("        {");
                sb.AppendLine("            var size = 0;");
                
                foreach (var member in nestedMembers)
                {
                    var memberType = GetMemberType(member);
                    if (memberType.SpecialType == SpecialType.System_String)
                    {
                        sb.AppendLine($"            size += sizeof(int); // Size for string length");
                        sb.AppendLine($"            size += System.Text.Encoding.UTF8.GetByteCount(obj.{member.Name});");
                    }
                    else if (memberType.IsUnmanagedType)
                    {
                        sb.AppendLine($"            size += sizeof({memberType.ToDisplayString()}); // Size for unmanaged type {member.Name}");
                    }
                }
                
                sb.AppendLine("            return size;");
                sb.AppendLine("        }");
                sb.AppendLine();
                
                // Generate Deserialize for nested type
                sb.AppendLine($"        public static {nestedType.Name} Deserialize(ReadOnlySpan<byte> data, out int bytesRead)");
                sb.AppendLine("        {");
                sb.AppendLine("            bytesRead = 0;");
                sb.AppendLine("            var originalData = data;");
                sb.AppendLine($"            var obj = new {nestedType.Name}();");
                
                foreach (var member in nestedMembers)
                {
                    var memberType = GetMemberType(member);
                    if (memberType.SpecialType == SpecialType.System_String)
                    {
                        sb.AppendLine($"            obj.{member.Name} = data.ReadString();");
                    }
                    else if (memberType.IsUnmanagedType)
                    {
                        sb.AppendLine($"            obj.{member.Name} = data.Read{memberType.Name}();");
                    }
                }
                
                sb.AppendLine("            bytesRead = originalData.Length - data.Length;");
                sb.AppendLine("            return obj;");
                sb.AppendLine("        }");
                sb.AppendLine();
                
                // Generate Serialize for nested type
                sb.AppendLine($"        public static int Serialize({nestedType.Name} obj, Span<byte> data)");
                sb.AppendLine("        {");
                sb.AppendLine("            var originalData = data;");
                
                foreach (var member in nestedMembers)
                {
                    var memberType = GetMemberType(member);
                    if (memberType.SpecialType == SpecialType.System_String)
                    {
                        sb.AppendLine($"            data.WriteString(obj.{member.Name});");
                    }
                    else if (memberType.IsUnmanagedType)
                    {
                        sb.AppendLine($"            data.Write{memberType.Name}(obj.{member.Name});");
                    }
                }
                
                sb.AppendLine("            return originalData.Length - data.Length;");
                sb.AppendLine("        }");
                sb.AppendLine("    }");
            }
        }

        sb.AppendLine("}");
        return sb.ToString();
    }
}